* 6 Enums and pattern matching
  - enums - enumerations
  - allow you to define a type by enumerating it's possible
 
** chapter goals
   - show what enums are
   - then explore the ~option~ enum
   - then pattern matching w/ ~match~
   - then, ~if / let~ 

     
* 6.1 defining an enum
  :PROPERTIES:
  :header-args:rust: :tangle ./ch6-1/src/main.rs
  :END:
  
  - here's an example where enums may be more useful than structs
  - since there are two possible types of IP address that we could come across, we can enumerate those possibilities
  #+begin_src rust
enum IpAddrKind {
    V4,
    V6,
}
  #+end_src
  
 
** enum values
   #+begin_src rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;

fn route(ip_kind: IpAddrKind) {}
   #+end_src
   - so, subtypes of an enum are accessible using the double colon syntax - that is how they are namespaced
   - now we can create functions that take either ~type~, because the type of each is ~IpAddrKind~
   
   
** ok, so now combining enums and structs
   - wow, this seems quite useful in order to associate the address w/ the type of enum
   #+begin_src rust
struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};

   #+end_src
   
** however, this can be done just by an enum!
   - to do this, we define that each of the enum variants will have a ~String~ associated with it
   #+begin_src rust
enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from("127.0.0.1"));
let loopback = IpAddr::V6(String::from("::1"));
   #+end_src
- this way, we don't need to define the additional struct to hold the address data!



** enum variant types can have different types and amounts of associated data
   - ok so watch this flexibilitym, that would not be possible with a struct
   - IPv4 addresses always have four sets of three numbers in [0,255]
   - if we wanted to store those four numbers themselves and still store the V6 address as a string, we could do the following
   - 
   #+begin_src rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from("::1"));
   #+end_src

  
** working with IP addresses is so common  that the ~std~ library contains a definition for them
  [[https://doc.rust-lang.org/std/net/enum.IpAddr.html][IpAddr in std::net - Rust]] 
  - so the way it's implemented there is that there ARE structs for Ipv4Addr and Ipv6Addr, with are then included in the ~enum~ ~IpAddr~
  - one thing is that since we haven't brought ~stdlib~ into scope, we can define our own versions no problem
  - 

** message enum demonstrating storage of different 
   
    - quit: has no data associated with it
    - move: has named fields like a struct
    - Write: has one String value
    - ChangeColor: three i32's
    #+begin_src rust
// as an enum
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32,i32,i32),
}

// the equivalent structs
struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct

    #+end_src

** we can define methods on ~enums~ using ~impl~
   #+begin_src rust
impl Message {
    fn call(&self) {
        // ma method body
    }
}

let m = Message::Write(String::from("hello"));
m.call();
   #+end_src
   - in the example above, we are showing that ~m~ is the ~Write~ variant of the ~Message~ enum
   
** The ~Option~ Enum and its Advantages Over Null Values
   - ~Option~ is another enum define in the standard library
   - this enum is so common that it, AND its variants, are "included in the prelude" -> you don;t have to explicitly import them
     - Aka you can call ~Some~, ~None~ without the ~Option~ prefix
   - The ~Option~ enum covers the situation where a value may be something, or it may be nothing
   - the advantage to covering this very common situation in this way as opposed to using Null is that the compiler is able to check all cases before compilation
   - aka, avoids tons of errors that are possible due to the way the Null type is usually implemented

*** the concept of null is good
Null values handle the situation in which a value is either absent or invalid
The implementation problem is that when a null value is used as a non-nul value, errors will result

*** The ~Option~ Enum
    #+begin_src rust
enum Option<T> {
    None,
    Some(T),
}
    #+end_src
*** the <T> syntax and the type differences it causes
- so, the variants are of the type ~Option<T>~
- the =T= is a "generic type parameter" -> more in ch. 10
- "for now, all you need to know is that ~<T>~ means the ~Some~ variant of the ~Option~ enum can hold one piece of data at any time, and that each concrete type that gets used in palce of ~T~ makes the overall ~Option<T>~ type a different type"
#+begin_src rust
let some_number = Some(5); // type is Option<i32>
let some_string = Some("a string"); // type is Option<&str>

let absent_number: Option<i32> = None; 
#+end_src
-  we *annotate the type* for the example of ~absent_number~ above, because rust can't infer from the ~None~ value that we want the type of ~absent_number~ to be ~Option<i32>~
- effectively what will get returned from the examples below are values of the type ~Option<<whatever type>>~, instead of just ~<Type>~

#+begin_src rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
#+end_src
- this is where the error will be: can't add an ~i8~ to an ~Option<i8>~
- "in short, because they are different types, the compiler won't let us use an ~Option<T>~ /as if it were definitely a valid value/"
*** why have this variation in type?
    - we have this difference because it allows us to compare whether a value is safe, and will always exist, or whether there may or may not be a value there
*** TODO rewrite this section
    - eliminating the rrisk of incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt-in by making the type of that value ~Option<T>~
*** so, how do you get the ~T~ value out of a ~Some~ variant?
    - ~Option<T>~ has a very large number of available methods
    - they will be extremely useful
    - highly recommended to check out the  [[https://doc.rust-lang.org/std/option/enum.Option.html][documentation for ~Option<T>~ methods]]
*** To use ~Option<T>~ values (in general), you must have code to handle each variant
    - you want code for if you have a ~Some(T)~ value that is able to use the inner ~T~
    - you want code for if you have a ~None~ value, "and that code doesn't have a ~T~ value available.
    - ooh here we go, the ~Match~ expression!

    
